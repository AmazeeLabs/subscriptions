<?php
// $Id$
/**
 * Implementation of hook_help().
 */
function subscriptions_help($section) {
  switch ($section) {
    case 'admin/help#subscriptions':
      // appears on the admin module help page
      return t('
        <p>This module enables users to subscribe to be notified of changes to threads or categories.
        Once enabled, all nodes will have an additional link that allows the user to change their subscriptions.
        Additionally, all users will be given an account option to auto-subscribe to any thread to which they post.
        No configuration is required for this module, although roles must be given permission to
        use it.</p>
        <p>While no configuration is required, administrators are offered a few configurable options:</p>
        
				<p>"<b>Omitted vocabularies</b>" allows the admin to exclude certain node categories from this list of those
				available for subscription.</p>
				<p>"<b>Use cron for notifications</b>" allows you to postpone subscription
				notifications until the next cron job is run.  Default behavior is to notify all subscribers immediately
				upon content change.  This behavior is probably best for low volume sites, but high volume sites could
				observe appreciable pauses upon node or comment insert, and should probably use the cron option.
				<p>"<b>Display watchdog entries for successful mailings</b>" should also probably be disabled for high volume sites,
				as a large number of mailings could completely fill the log.</p>
				<p>"<b>Test held posts prior to sending</b>" tells Subscriptions to test if a node or comment
				is still active\published prior toi sending a notification.  This is mainly to avoid sending
				notifications for for posts that have been deleted.  This will result in a small performance
				hit, and only makes sense if you are delaying the notifications with "Use cron for notifications".</p>');
    case 'admin/modules#description':
      // appears on the admin module selection page
      return t('Allows users to subscribe to nodes and taxonomy terms.');
  }
}
/**
 * Implementation of hook_perm().
 */
function subscriptions_perm() {
  return array('maintain subscriptions');
}
/**
 * Implementation of hook_user().
 */
function subscriptions_user($type, $edit, &$user, $category = NULL) {
  switch ($type) {
    case 'form':
      if (user_access('maintain subscriptions') && $category == 'account') {
        $form['subscriptions'] = array(
          '#type'        => 'fieldset', 
          '#title'       => t('Subscription settings'), 
          '#weight'      => 5, 
          '#collapsible' => TRUE
        );
        $form['subscriptions']['subscriptions_auto'] = array(
          '#type'          => 'checkbox',
          '#title'         => t('Autosubscribe'),
          '#default_value' => isset($edit['subscriptions_auto']) ? $edit['subscriptions_auto'] : $user->subscriptions_auto,
          '#description'   => t('Checking this box allows you to be automatically subscribe to any thread you create or post a comment to.')
        );
      return $form;
      }
    break;
  }
}
/**
 * Implementation of hook_settings().
 */
function subscriptions_settings() {
  $vocabularies = taxonomy_get_vocabularies();
  $select[0] = '<'. t('none') .'>';
  foreach ($vocabularies as $vocabulary) {
    $select[$vocabulary->vid] = $vocabulary->name;
  }
  $form['sub_settings']['subscriptions_omitted_taxa'] = array(
    '#type'          => 'select',
    '#title'         => t('Omitted vocabularies'),
    '#default_value' => variable_get('subscriptions_omitted_taxa', array()),
    '#options'       => $select,
    '#description'   => t('Select vocabularies which should be <strong>omitted</strong> from subscription listings.'),
    '#multiple'      => TRUE
  );  
  $form['sub_settings']['subscriptions_usecron'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Use cron for notifications'),
    '#default_value' => variable_get('subscriptions_usecron', 0),
    '#description'   => t("Sends subscription notification when cron module runs.  Default is to send upon node update.  <em>Note:  Currently only works with MySQL.</em>"),
  );
  $form['sub_settings']['subscriptions_watchgood'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Display watchdog entries for successful mailings'),
    '#default_value' => variable_get('subscriptions_watchgood', 1),
    '#description'   => t('Inserts notification of successful mailings in the watchdog log.  Default is ON.'),
  );
  $form['sub_settings']['subscriptions_testpost'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Test held posts prior to sending'),
    '#default_value' => variable_get('subscriptions_testpost', 0),
    '#description'   => t('Tests to see if a post about to be sent by cron is still active.  Adds a small amount of overhead.  Default is OFF.'),
  );
  return $form;
}
/**
 * Returns all subscriptions, and displayed metadata, for a given user.
 * (uses caching)
 */
function subscriptions_get_user($account = NULL) {
  global $user;
  static $subscriptions;
  if (is_null($account)) {
    $account = $user;
  }
  if (is_null($subscriptions[$account->uid])) {
    // query string for node subscriptions
    $queryn = 'SELECT td.tid, td.name, n.nid, n.title, s.stype, s.sid FROM ';
    $queryn .= '(({subscriptions} s LEFT JOIN {node} n ON n.nid = s.sid) ';
    $queryn .= 'LEFT JOIN {term_node} tn ON tn.nid = s.sid) ';
    $queryn .= 'LEFT JOIN {term_data} td ON td.tid = tn.tid ';
    $queryn .= 'WHERE n.status = 1 AND s.uid = %d AND s.stype = \'node\'';
    // query string for blog subscriptions (by blog owner)
    $queryb = 'SELECT u.uid, u.name, s.stype, s.sid FROM ';
    $queryb .= '({subscriptions} s LEFT JOIN {users} u ON u.uid = s.sid) ';
    $queryb .= 'WHERE u.status = 1 AND s.uid = %d AND s.stype = \'blog\'';
    // query string for category subscriptions
    $queryt .= 'SELECT td.tid, td.name FROM ';
    $queryt .= '{subscriptions} s INNER JOIN {term_data} td ON td.tid = s.sid ';
    $queryt .= 'WHERE s.uid = %d AND s.stype = \'taxa\'';
    $resultn = db_query($queryn, $account->uid);
    $resultb = db_query($queryb, $account->uid);
    $resultt = db_query($queryt, $account->uid);
    $subscriptions[$account->uid]['node'] = $subscriptions[$account->uid]['taxa'] = $subscriptions[$account->uid]['blog'] = array();
    while ($nsub = db_fetch_object($resultn)) {
      $subscriptions[$account->uid]['node'][$nsub->nid] = $nsub;
    }
    while ($bsub = db_fetch_object($resultb)) {
      $subscriptions[$account->uid]['blog'][$bsub->uid] = $bsub;
    }
    while ($tsub = db_fetch_object($resultn)) {
      $subscriptions[$account->uid]['taxa'][$tsub->tid] = $tsub;
    }
  }
  return $subscriptions[$account->uid];
}
/*
 * Returns a summary of all subscriptions
 */
function subscriptions_get_summary() {
  static $subssumm;
  // query string for node subscriptions
  $queryn = 'SELECT n.nid, n.title, s.sid, COUNT(*) as ncount FROM ';
  $queryn .= '{subscriptions} s INNER JOIN {node} n ON n.nid = s.sid ';
  $queryn .= 'WHERE s.stype = \'node\' ';
  $queryn .= 'GROUP BY n.nid, n.title, s.sid ';
  $queryn .= 'ORDER BY s.sid ';
  // query string for blog subscriptions (by blog owner)
  $queryb = 'SELECT u.uid, u.name, s.sid, COUNT(*) as ncount FROM ';
  $queryb .= '{subscriptions} s INNER JOIN {users} u ON u.uid = s.sid ';
  $queryb .= 'WHERE s.stype = \'blog\' ';
  $queryb .= 'GROUP BY u.uid, u.name, s.sid ';
  $queryb .= 'ORDER BY s.sid ';
  // query string for category subscriptions
  $queryt .= 'SELECT s.sid, td.name, COUNT(*) as ncount FROM ';
  $queryt .= '{subscriptions} s RIGHT JOIN {term_data} td ON td.tid = s.sid ';
  $queryt .= 'WHERE s.stype = \'taxa\' ';
  $queryt .= 'GROUP BY s.sid, td.name ';
  $queryt .= 'ORDER BY s.sid ';
  $resultn = db_query($queryn);
  $resultb = db_query($queryb);
  $resultt = db_query($queryt);
  $subssumm['node'] = $subssumm['taxa'] = $subssumm['blog'] = array();
  while ($nsub = db_fetch_object($resultn)) {
    $subssumm['node'][$nsub->nid] = $nsub;
  }
  while ($bsub = db_fetch_object($resultb)) {
    $subssumm['blog'][$bsub->uid] = $bsub;
  }
  while ($tsub = db_fetch_object($resultn)) {
    $subssumm['taxa'][$tsub->tid] = $tsub;
  }
  return $subssumm;
}
/*
 * Formats the mail and sends it.
 */
function subscriptions_sendmail($name, $to, $subject, $body, $headers) {
  $mail_success = user_mail($to, $subject, $body, $headers);
  if ($mail_success) {
  	if(variable_get('subscriptions_watchgood', 1) == 1){
      watchdog('regular', t('subscription notification for ') .'"'. $name .'" &lt;'. $to .'&gt;');
    }
  }
  else {
    watchdog('error', t('error mailing subscription notification: ') .'"'. $name .'"  &lt;'. $to .'&gt;');
  }
}
/*
 * Get e-mail vars
 */
function subscriptions_mailvars($sid, $ssid, $uid, $stype, $strsent) {
  global $base_url;
  global $locale;
  $initial_locale = $locale;
  if (function_exists('locale')) {
    $languages = locale_supported_languages();
    $languages = $languages['name'];
  }
  $from = variable_get('site_mail', ini_get('sendmail_from'));
  // if comment insertion, get vars
  if ($stype == 'node') {
    $result = db_query('SELECT title FROM {node} WHERE nid = %d', $sid);
    $subj = db_result($result);
    $result = db_query('SELECT u.uid, u.name, u.mail, u.language FROM {users} u INNER JOIN {subscriptions} s ON u.uid = s.uid WHERE s.sid = %d AND s.stype = \'node\'', $sid);
    $strtype = 'thread';
    $nid = $sid;
    $cid = "comment-$ssid";
  }
  // if node insert, test if node has a taxonomy else skip
  if ($stype == 'taxa' && !is_null($sid)) {
    $result = db_query('SELECT name FROM {term_data} WHERE tid = %d', $sid);
    $subj = db_result($result);
    $result = db_query('SELECT u.mail, u.name, u.uid, u.language FROM {users} u INNER JOIN {subscriptions} s ON u.uid = s.uid WHERE s.sid = %d AND stype = \'taxa\'', $sid);
    $strtype = 'category';
    $nid = $ssid;
    $cid = NULL;
  }
  // if blog insert, get vars
  if ($stype == 'blog') {
    $result = db_query('SELECT name FROM {users} WHERE uid = %d', $uid);
    $subj = t('new blog for ') . db_result($result);
    $result = db_query('SELECT u.uid, u.name, u.mail, u.language FROM {users} u INNER JOIN {subscriptions} s ON u.uid = s.uid WHERE s.sid = %d AND s.stype = \'blog\'', $sid);
    $strtype = 'blog';
    $nid = $ssid;
    $cid = NULL;
  } 
  // loop through subscribers and call mail function
  while ($subscriptions = db_fetch_object($result)) {
    if ($subscriptions->uid != $uid && !is_null($sid) && strpos($strsent , '!'. $subscriptions->uid .'!') === false) {
      // add this user to "previously notified" string
      $strsent .= $subscriptions->uid .'!';
      // translate the message using the reciever's language
      if (function_exists('locale') && $languages[$subscriptions->language]) {
        $locale = $subscriptions->language;
      }
      $headers = "From: $from\nReply-to: $from\nX-Mailer: Drupal\nReturn-path: $from\nErrors-to: $from";
      $subject = t('[%site] %type subscription update for %name : %subject', array('%site' => variable_get('site_name', 'drupal'), '%type' => $strtype, '%name' => $subscriptions->name, '%subject' => $subj));
      $body = t("Greetings, %name.\n\nA %type to which you have subscribed has been updated.\nTo view the thread, navigate to %url \n\n--\nThis is an automatic message from %site.\nTo manage your subscriptions, browse to %manage-url", array('%name' => $subscriptions->name, '%type' => $strtype, '%url' => url('node/'. $nid, NULL, $cid, 1), '%site' => variable_get('site_name', 'drupal'), '%manage-url' => url('subscriptions', NULL, NULL, 1)));
      // revert to original locale
      $locale = $initial_locale;
      subscriptions_sendmail($subscriptions->name, $subscriptions->mail, $subject, $body, $headers);
    }
  }
  return $strsent;
}
/*
 * Subscribes users to nodes in which they post, if not already subscribed
 */
function subscriptions_autosubscribe($uid, $nid) {
  global $user;
  // if user has auto subscribe enabled
  if ($user->subscriptions_auto) {
    // check to see if already subscribed
    $result = db_query('SELECT sid FROM {subscriptions} WHERE sid = %d AND stype = \'node\' AND uid = %d', $nid, $uid);
    if (!db_num_rows($result)) {
      // if not, subscribe
      subscriptions_add($nid, $user->uid, 'node');
    }
  }
}
/**
 * handling for held nodes
 */
function subscriptions_heldnodes($heldnode, $poster){
  $strsent = '!';
  $onode = unserialize($heldnode);
  if ($onode->status) {
    if (!empty($onode->taxonomy)) {
      foreach ($onode->taxonomy as $tid){
        $strsent = $strsent . subscriptions_mailvars($tid, $onode->nid, $poster, 'taxa', $strsent);
      }
    }
    $strsent = $strsent . subscriptions_mailvars($onode->nid, 0, $poster, 'node', $strsent);
    if ($node->type == 'blog') {
      $strsent = $strsent . subscriptions_mailvars($onode->uid, $onode->nid, $poster, 'blog', $strsent);
    }
  }
}
/**
 * handling for held comments
 */
function subscriptions_heldcomments($heldcomment, $poster){
  $strsent = '!';
  $ocom = unserialize($heldcomment);
  subscriptions_mailvars($ocom['nid'], $ocom['cid'], $poster, 'node', $strsent);
}
/**
 * store node changes for later handling
 */
function subscriptions_hold( $content, $ptype , $op, $pid ) {
  $strqry = 'INSERT INTO {subscriptions_holding} ( content, ptype , op, pid )  VALUES (\'%s\', \'%s\', \'%s\', %d)';
  db_query($strqry, serialize($content), $ptype, $op, $pid);
}
/**
 * Test to see if a post is still active before notifications are sent
 */
function subscriptions_testpost($content, $ptype){
	$content = unserialize($content);
	$valid = false;
  switch ($ptype) {
  case 'comment':  // comment handling
		$result = db_query('SELECT pid, status FROM {comments} WHERE cid = %d', $content['cid']);
		$row = db_fetch_object($result);
		if(!is_null($row->pid) && ($row->pid != 0) &&  ($row->status != 1)){$valid = true;}
		break;
	case 'node':  // node handling
		$result = db_query('SELECT status FROM {node} WHERE nid = %d', $content['cid']);
		if(db_result($result)==1){$valid = true;}
		break;
	}
	return $valid;
}
/**
 * Implementation of cron job.
 */
function subscriptions_cron() {
  if(variable_get('subscriptions_usecron', 0)){
    // get all currently held node updates
	$result = db_query('SELECT * FROM {subscriptions_holding} ');
	while ($row = db_fetch_object($result)) {
		$proceed = true;
		if(variable_get('subscriptions_testpost', 0)){$proceed = subscriptions_testpost($row->content,$row->ptype);}
		if($proceed){
		  // do send
		  if($row->ptype == 'comment'){
	    subscriptions_heldcomments($row->content, $row->puid);
	    // delete processed row
	    db_query('DELETE FROM {subscriptions_holding} WHERE rid = %d', $row->rid);
	  } // row type == 'comment'
	  if($row->ptype == 'node'){
	    subscriptions_heldnodes($row->content, $row->puid);
	    // delete processed row
	    db_query('DELETE FROM {subscriptions_holding} WHERE rid = %d', $row->rid);
	  } // row type == 'node'
		}else{
		  // do delete
		  db_query('DELETE FROM {subscriptions_holding} WHERE rid = %d', $row->rid);
		}
	} // for each row in results set
  }  // if using cron to send notifications
}
/**
 * Implementation of hook_comment().
 */
function subscriptions_comment($comment, $op) {
  global $user;
  $strsent = '!';
  // TODO: it appears the comment status is not provided by this hook... we'll have to look into that later
  if (/* $comment['status'] == 0 && */ ($op == 'insert' || ($op == 'update' && $comment->status == 1))) { // ignore deactivated comments
    //  if use_cron is set, insert node actions into holding table
    if(variable_get('subscriptions_usecron', 0)){
      subscriptions_hold( $comment, 'comment' , $op, $user->uid );
    } else {  // if cron is not used
      $nid = $comment['nid'];
      $cid = $comment['cid'];
      subscriptions_mailvars($nid, $cid, $user->uid, 'node', $strsent);
    } // end cron test
    subscriptions_autosubscribe($user->uid, $nid);
  }
}
/**
 * Implementation of hook_nodeapi().
 */
function subscriptions_nodeapi(&$node, $op, $arg = 0) {
  global $user;
  $strsent = '!';
  switch ($op) {
    case 'update':  // fall through
    case 'insert':
	  if($op == 'update') {
	    // If node was previously published, no need to go further
        $oldnode = node_load(array('nid' => $node->nid));
        if ($oldnode->status == 1) {  // only want 0->1
          break;
        }
        // Otherwise, fall through
    }
	  if (variable_get('subscriptions_usecron', 0)) {
	  	// using cron to send notifications
	  	subscriptions_hold( $node, 'node' , $op, $user->uid );
	  }
		else {  // sending notification on submission
	    if ($node->status) {
	      if (!empty($node->taxonomy)) {
	        foreach ($node->taxonomy as $tid){
	          $strsent = $strsent . subscriptions_mailvars($tid, $node->nid, $user->uid, 'taxa', $strsent);
	        }
	      }
	      $strsent = $strsent . subscriptions_mailvars($node->nid, 0, $user->uid, 'node', $strsent);
	      if ($node->type == 'blog') {
	        $strsent = $strsent . subscriptions_mailvars($node->uid, $node->nid, $user->uid, 'blog', $strsent);
	      }
	      subscriptions_autosubscribe($user->uid, $node->nid);
	    }
    }  // cron test
    if (isset($node->subscriptions_subscribe)) {
      if ($node->subscriptions_subscribe) {
        subscriptions_add($node->nid, $user->uid, 'node');
      }
      user_save($user, array('subscriptions_subscribe' => $node->subscriptions_subscribe));
    }
  break;
  }
}
/**
 * Implementation of hook_form_alter().
 */
function subscriptions_form_alter($form_id, &$form) {
  global $user;
  $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);
  if (!$user->subscriptions_auto && $node->comment == COMMENT_NODE_READ_WRITE && $user->uid) {
    $allsubs = subscriptions_get_user();
    $val = isset($node->subscriptions_subscribe) ? $node->subscriptions_subscribe : $allsubs['node'][$node->nid] ? 1 : $user->subscriptions_subscribe;
    if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
      $node = $form['#node'];
      $form['subscriptions'] = array(
        '#type'        => 'fieldset',
        '#title'       => t('Subscriptions'),
        '#collapsible' => TRUE,
        '#weight'      => 0,
      );
      $form['subscriptions']['subscriptions_subscribe'] = array(
        '#type'          => 'checkbox', 
        '#title'         => t('Subscribe'),
	  		'#description'   => t('Receive notification of replies or comments to this node.'),
        '#default_value' => $val, 
      );
    }
	 }
}
/**
 * Implementation of hook_menu().
 */
function subscriptions_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array('path' => 'subscriptions', 'title' => t('my subscriptions'),
      'access' => user_access('maintain subscriptions'),
      'callback' => 'subscriptions_page');
    $items[] = array('path' => 'subscriptions/feed', 'title' => t('my subscriptions feed'),
      'access' => user_access('maintain subscriptions'),
      'callback' => 'subscriptions_feed');
    $items[] = array('path' => 'admin/subscriptions', 'title' => t('subscriptions'),
      'access' => user_access('administer users'),
      'callback' => 'subscriptions_page');
  }
  return $items;
}
/**
 * Implementation of hook_link().
 */
function subscriptions_link($type, $node = 0, $main) {
  if (user_access('maintain subscriptions') && $type == 'node' && $node->comment == 2) {
    $subscriptions = subscriptions_get_user();
    $name = node_invoke($node->type, 'node_name');
    if ($node->type == 'blog') {
      if (isset($subscriptions['blog'][$node->uid])) {
        $links[] = l(t('unsubscribe blog'), 'subscriptions/del/blog/'. $node->uid, array('title' => t('Stop receiving an e-mail whenever a new entry is made to this person\'s blog.')));
      }
      else {
        $links[] = l(t('subscribe blog'), 'subscriptions/add/blog/'. $node->uid, array('title' => t('Receive an e-mail whenever a new entry is made to this person\'s blog.')));
      }
    }
    if (isset($subscriptions['node'][$node->nid])) {
      $links[] = l(t('unsubscribe post'), 'subscriptions/del/node/'. $node->nid, array('title' => t('Stop receiving an e-mail whenever a new comment is posted to this %n.', array('%n' => $name))));
    }
    else {
      $links[] = l(t('subscribe post'), 'subscriptions/add/node/'. $node->nid, array('title' => t('Receive an e-mail whenever a comment is posted to this %n.', array('%n' => $name))));
    }
  }
  return $links ? $links : array();
}
function subscriptions_get_taxa($uid) {
  $result = db_query('SELECT sid FROM {subscriptions} WHERE uid = %d and stype=\'taxa\'', $uid);
  while ($taxasub = db_fetch_object($result)) {
    $tsubscriptions[] = $taxasub->sid;
  }
  return $tsubscriptions ? $tsubscriptions : array();
}
function subscriptions_get_taxa_count() {
  $result = db_query('SELECT sid, count(*) as tcount FROM {subscriptions} WHERE stype=\'taxa\' GROUP BY sid');
  while ($taxasub = db_fetch_object($result)) {
    $tsubscriptions[$taxasub->sid] = $taxasub->tcount;
  }
  return $tsubscriptions ? $tsubscriptions : array();
}
function subscriptions_gen_taxa_links($tid, $taxa) {
  if (in_array($tid, $taxa)) {
    $link = l(t('unsubscribe'), 'subscriptions/del/taxa/'. $tid, array('title' => t('Unsubscribe from this category.')));
  }
  else {
    $link = l(t('subscribe'), 'subscriptions/add/taxa/'. $tid, array('title' => t('Subscribe to this category.')));
  }
  return $link;
}
function subscriptions_add($sid, $uid, $stype) {
  db_query('INSERT INTO {subscriptions} ( sid , uid, stype )  VALUES (%d , %d, \'%s\')', $sid, $uid, $stype);
}
/*
 * Menu callback:
 * Pages where users add and delete their subscriptions to nodes
 * TODO: add destination= on the links which subscribe you and admin links and add a drupal_goto here. this gets rid of the silly 'go back now' page.
 */
function subscriptions_page() {
  global $user;
  $subscribed = false;
  $uid = $user->uid;
  if (!arg(2)) {
    $sid = arg(1);
    $nid = $sid;
    $op = arg(0);
  }
  else {
    $op = arg(1);
    $stype = arg(2);
    $sid = arg(3);
    $nid = arg(4);
    if ($stype == 'node') {
      $nid = $sid;
    }
  }
  
  //  determine return location
  if(is_null($_SERVER['HTTP_REFERER'])){
  	$rtnloc = "node/$node->nid";
  } else {
	if(variable_get('clean_url', 0) == 1){  // clean URLs on
      global $base_url;
		// extract $base_url from $_SERVER['HTTP_REFERER']
		$istart = strlen($base_url) + 1;
		$rtnloc = substr($_SERVER['HTTP_REFERER'],$istart);
	}else {
		// split $_SERVER['HTTP_REFERER'] at "q="
		$istart = strpos($_SERVER['HTTP_REFERER'], 'q=') + 2;
		$rtnloc = substr($_SERVER['HTTP_REFERER'],$istart);
	}
  	$return = $_SERVER['HTTP_REFERER'];
  } // end determine return location
  
  switch ($op) {
    // inserts a new subscription into the subscriptions_nodes table
    case 'add':
      subscriptions_add($sid, $uid, $stype);
      $message = t('Your subscription was activated.');
      drupal_set_message($message);
      drupal_goto($rtnloc);
      break;
    // removes a subscription from the subscriptions_nodes table
    case 'del':
      db_query('DELETE FROM {subscriptions} WHERE sid = %d AND uid = %d AND stype = \'%s\'', $sid, $uid, $stype);
      $message = t('Your subscription was deactivated.');
      drupal_set_message($message);
      drupal_goto($rtnloc);
      break;
    // Base report for admin functions
    case 'admin':
      // get all subscriptions for all users
      $subscriptions = subscriptions_get_summary();
      // build node rows
      foreach ($subscriptions['node'] as $nsub) {
        $subrowsn[] = array(t('thread'), l($nsub->title, 'node/'. $nsub->nid), $nsub->ncount);
      }
      // build blog rows
      foreach ($subscriptions['blog'] as $bsub) {
        $subrowsb[] = array(t('blog'), l($bsub->name, 'blog/'. $bsub->uid), $bsub->ncount);
      }
      // traverse the taxonomy tree
      $taxa = subscriptions_get_taxa_count();
      // omit undesired vocabularies from listing
      $vocabularies = taxonomy_get_vocabularies();
      $omits = variable_get('subscriptions_omitted_taxa', array());
      foreach ($omits as $omit) {
        unset($vocabularies[$omit]);
      }
      foreach ($vocabularies as $vocab) {
        $tree = taxonomy_get_tree($vocab->vid);
        foreach ($tree as $term) {
          $subrowst[] = array(t('category'), $vocab->name .': '. l($term->name, 'taxonomy/term/'. $term->tid), is_null($taxa[$term->tid]) ? '0' : $taxa[$term->tid]);
        }
      }
      // concatentate the arrays
      $headers = array(t('type'), t('title'), t('subscribers'));
      $subrows = array_merge((array) $subrowsn, (array) $subrowsb, (array) $subrowst);
      // assemble output
      if (!$subrows) {
        $message .= t('<p>No threads or categories are currently subscribed.</p>');
      }
      else {
        $message .= theme('table', $headers, $subrows, array('id' => 'subscriptions'));
      }
      drupal_set_title(t('Subscriptions Summary'));
      return $message;
      break;
    // determines the user's subscription status and displays the right option to change it
    default:
      // get all subscriptions and write to table rows
      $subscriptions = subscriptions_get_user();
      // build node rows
      foreach ($subscriptions['node'] as $nsub) {
        $subrowsn[] = array(t('thread'), l($nsub->title, 'node/'. $nsub->nid), '['. l(t('unsubscribe'), 'subscriptions/del/node/'. $nsub->nid, array('title' => t('Unsubscribe from this thread.'))) .']');
      }
      // build blog rows
      foreach ($subscriptions['blog'] as $bsub) {
        $subrowsb[] = array(t('blog'), l($bsub->name, 'blog/'. $bsub->uid), '['. l(t('unsubscribe'), 'subscriptions/del/blog/'. $bsub->uid, array('title' => t('Unsubscribe from this user\'s blog.'))) .']');
      }
      // traverse the taxonomy tree
      $taxa = subscriptions_get_taxa($uid);
      // omit undesired vocabularies from listing
      $vocabularies = taxonomy_get_vocabularies();
      $omits = variable_get('subscriptions_omitted_taxa', array());
      foreach ($omits as $omit) {
        unset($vocabularies[$omit]);
      }
      foreach ($vocabularies as $vocab) {
        $tree = taxonomy_get_tree($vocab->vid);
        foreach ($tree as $term) {
          $subrowst[] = array(t('category'), $vocab->name .': '. l($term->name, 'taxonomy/term/'. $term->tid), '['. subscriptions_gen_taxa_links($term->tid, $taxa) .']');
        }
      }
      // concatentate the arrays
      $headers = array(t('type'), t('title'), t('operations'));
      $subrows = array_merge((array) $subrowsn, (array) $subrowsb, (array) $subrowst);
      if (!$subrows) {
        $message .= t('<p>You are not currently subscribed to any active threads or categories.</p>');
      }
      else {
        $message .= theme('table', $headers, $subrows, array('id' => 'subscriptions'));
      }
      
      $message .= theme('xml_icon', url("subscriptions/feed"));
      drupal_add_link(array('rel' => 'alternate',
                          'type' => 'application/rss+xml',
                          'title' => t("%name Subscriptions", array('%name' => $user->name)),
                          'href' => url('subscriptions/feed')));
      return $message;
      break;
  }
}
function subscriptions_feed($account = NULL) {
  if (is_null($account)) {
    global $user;
    $account = $user;
  }
  
  $subs = subscriptions_get_user($account);
  if ($nodes = $subs['blog']) {
    $uids = implode(',', array_keys($nodes));
    $cond[] = "(n.type = 'blog' AND n.uid IN ($uids))";
  }
  if ($nodes = $subs['node']) {
    $nids = implode(',', array_keys($nodes));
    $cond[] = "n.nid IN ($nids)";
  }
  if ($taxas = $subs['taxa']) {
    $tids = implode(',', array_keys($taxas));
    $cond[] = "tn.tid IN ($tids)";
  }
    
  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {term_node} tn ON n.nid=tn.nid";
  if ($cond) { 
    $sql.= " WHERE ". implode(' OR ', $cond);
  }
  $sql .= " GROUP BY n.nid ORDER BY n.created DESC";
  $result = db_query_range(db_rewrite_sql($sql), 0, variable_get('feed_default_items', 10));
  $channel['title'] = t("%name Subscriptions", array('%name' => $account->name));
  $channel['link'] = url("subscriptions/feed", NULL, NULL, TRUE);
  // $channel['description'] = ;
  node_feed($result, $channel);
}
